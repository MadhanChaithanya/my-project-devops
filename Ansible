Ansible
========================================================
Day 1
=========================================================



Configuration Management
=============================
This is the process of configuring applications remotely on
multiple servers from one point of control

Advantages
==============
1 Provisioning of Servers
  Activites like installing patches,deleting applications,
installing and upgrading s/w etc can be done very quickly on any
number of servers

2 Useful in Disaster Recovery
  In disaster recovery scenarios when an entire data center can go
bad we have to maintain a replica data center in some other location
Creation of such replica data center can be done easily using 
configuration management tools

3 Handling Snowflake Servers
  After a point of time each server present in a data center can behave
like a snow flake ie it can be running on different h/w and s/w configurations
Configuration Management tools can capture this information and store
in simple files called as "setup" files which can be used for configuring
similar environments

4 Idempotent
  Configuration Management tools are used to bring the servers to a
specific state called as "Desired state". If the remote servers are in the
desired state Configuration Management tools will not reconfigure
that server

Poplular configuration managment tools
==============================================
1 Ansible
2 Chef
3 Puppet
4 Saltstack

Ansible
===============
This is an opensource configuration managment tool created using python
The main machine where ansible is installed is called as Controller
and the remaining servers are called as managed nodes/managed hosts

Ansible is called as "agentless" as it doesnot require any client
side s/w .It perfroms remote configuration using "push" methodology
This is done via passwordless ssh
Day-2
=========================================================================
Setup of Ansible
====================
1 Create 3 or 4 AWS ubuntu-18 instances
2 NAme the 1st one as controller and remaining 2 as server1 and server2
3 Establish Passwordless ssh from Controller to Server1 and Server2
  a) Connect to server1 using gitbash
  b) Setup password for the default user
     sudo passwd ubuntu
  c) Edit the ssh configuration file
     sudo vim /etc/ssh/sshd_config
     Search for "PasswordAuthentication" and change it from no to yes
  d) Restart ssh
     sudo service ssh restart
     Repeat the above steps from a to d on Server2 managed node
  e) Connect to Controller using git bash
  f) Generate the ssh keys
     ssh-keygen
  g) Copy the ssh keys
     ssh-copy-id ubuntu@private_ip_of_server1
     Repeat step g with ipaddress of Server2

4 Installing Ansible
  a) Update the apt repository
     sudo apt-get update
  b) Install software-properties-common
     sudo apt-get install -y software-properties-common
  c) Add the latest version of Ansible to apt repository
     sudo apt-add-repository ppa:ansible/ansible
  d) Update the apt repository
     sudo apt-get update
  e) Install ansible
     sudo apt-get install -y ansible

5 To check the verision of ansible
  ansible --version

Ansible stores all the remote servers info in a file called as inventory file
We should open this file and store the ipaddress of all the managed nodes here

sudo vim /etc/ansible/hosts
Here copy and paste the ipaddresses of the managed nodes









Ansible can perform remote configuration of servers in
3 different ways
1 Adhoc commands
2 Playbooks
3 Roles

Ansible uses inbuilt python modules to do the configurations
on remote servers

Important modules in Ansible
================================
command: This is used to execute linux commands on the remote servers
This is the default module of ansible

shell: This is used to execute shell scripts or commands involving
redirection and piping on the managed nodes

ping: This is used to check if the remote managed nodes are pingable 
or not

user: Used for user management of the remote servers like creating user
accounts,setting password,assigning home directories etc

file: Used to create/delete files and directories on the managed nodes

copy: USed for copying files/directories to managed nodes

fetch: Used to copy files/directories from managed nodes to controller

apt: This is used for s/w package management on remote servers
      like installing packages,upgrading deleting etc.It works on
      ubuntu flavour servers

yum: This is similar to apt but it works on centos,redhat etc

service: This is used to start stop and restart services on managed nodes

git: This is used to perform git version controlling on managed nodes

uri: This is used to check if a remote url is reachable from the managed node

get_url: This is used to download files from servers into the managed nodes

debug: Used to display out put of other modules in JSON file format

stat: Capture info about files and folders on managed nodes

include: USed to call child playbooks from a parent playbook

replace: Used to replace some section of the text in a file

pause: Used to pause the execution of playbook for some time

docker_container: Used to perfrom docker container activites on managed nodes

docker_image: Used to run docker image related commands on managed nodes

docker_login: Used to login into docker registry

Adhoc command syntax
==========================
ansible all/group_name/ipadresss -i path_of_inventory -m module_name -a 'arguments'




Command Module
=====================
Ansible command to see the memory info of all managed nodes
ansible all -i /etc/ansible/hosts -m command -a 'free' 


Note: /etc/ansible/hosts is the default inventory file and when using it
it is not manadatory to use -i option in the adhoc command
ansible all  -m command -a 'free'

Note: command module is the deafult module of ansible and when using it
we need not use -m option
ansible all   -a 'free'


Shell Module
======================
Ansible command to install docker on all the managed nodes
a) Downlaod the shell script for docker
   ansible all -m shell -a 'curl -fsSL https://get.docker.com -o get-docker.sh'
b) Execute the shell script to install docker
  ansible all -m shell -a 'sh get-docker.sh'

=======================================================================
Day 3
=========================================================================
Ansible command to capture memory info of all managed nodes and store in file1
ansible all -m shell -a 'free -m > file1'

===================================================================


User Module
================
1 Create a user and set a password
  ansible all -m user -a 'name=Sai password=intelliqit' -b

Note: -b represents "become" this is used for giving higher previlages on the
remote servers

2 Create user and set home dir,uid,shell,comment etc
  ansible all -m user -a 'name=Lakshmi password=intelliqit 
          home=/home/Lakshmi comment="A nromal user" uid=1111 shell=/bin/bash' -b

=====================================================================
file Module
===============
1 Ansible command to create a file on all managed nodes
  ansible all -m file -a 'name=/tmp/file1 state=touch'

Note: state=touch is for creating files
state=directory is for creating directories
state=absent is for deleting files or directories

File module can also control the ownership group owner ship and permissions
of files and directories created on managed nodes
ansible all -m file -a 'name=file1 state=touch owner=Sai group=Lakshmi mode=760' -b


=============================================================================
copy Module
===============
Ansible command to a file from the controler to managed nodes
ansible all -m copy -a 'src=file100 dest=/tmp'

Copy module can not only copy files it can also change the ownership
groupownership and permissions of files
ansible all -m copy -a 'src=file100 dest=/tmp owner=root group=Sai mode=700' -b

Copy module can also change the content of a file
ansible all -m copy -a 'src=file1 dest=/home/ubuntu/file2'

================================================================================
apt Module
================
Ansible command to uninstall git from all managed nodes
ansible all -m apt -a 'name=git state=absent' -b
ansible all -m apt -a 'name=git state=present' -b

Note: state=present is for installation
state=absent is for uninstallation
state=latest is for upgrading to a later version

To update the apt reposiotry and then install tree we use update_cache=yes
ansible all -m apt -a 'name=tree state=absent update_cache=yes' -b

Scenario
==============
Install tomcat8,tomcat8-admin and copy tomcat-users.xml file

1 Install tomcat8
  ansible all -m apt -a 'name=tomcat8 state=present' -b

2 Install tomcat8-admin
  ansible all -m apt -a 'name=tomcat8-admin state=present' -b

3 Create tomcat-users.xml file
  vim tomcat-users.xml
  <tomcat-users>
     <user username="intelliqit" password="intelliqit" roles="manager-script"/>
  </tomcat-users>

4 Copy the tomcat-users.xml file to all managed nodes
  ansible all -m copy -a 'src=tomcat-users.xml dest=/etc/tomcat8' -b

========================================================================
Day 4
==========================================================================


ServiceModule
====================
Ansible command to restart tomcat8 on all managed nodes
ansible all -m service -a 'name=tomcat8 state=restarted' -b

Note: state=started is for starting a service
state=stopped is for stopping
state=restarted is for restarting a service

=======================================================================
git Module
================
Clone a remote git repo into all managed nodes
ansible all -m git -a 'repo=https://github.com/intelliqittrainings/Kubernetes_demo.git dest=/tmp/dir1'

=======================================================================

Fetch module
========================
Copy the /etc/passwd file from all managed nodes
ansible all -m fetch -a 'src=/etc/passwd dest=/tmp'

Copy a file from one managed node to another managed node
-----------------------------------------------------------------
1 Fetch file from 1st managed node
  ansible 172.31.36.172 -m fetch -a 'src=file1 dest=/tmp'

2 Copy that fetched file into managed node 2
  ansible 172.31.37.220 -m copy -a 'src=/tmp/172.31.36.172/file1 dest=/home/ubuntu'

=============================================================================
replace module
===================
Ansible command to change the port of tomcat from 8080 to 9090
ansible all -m replace -a 'regexp=8080 replace=9090 path=/etc/tomcat8/server.xml' -b
ansible all -m service -a 'name=tomcat8 state=restarted' -b

===============================================================================
uri module
===================
Ansible command to check if google is reachable from all managed nodes
ansible all -m uri -a 'url=http://google.com status_code=200'

Note: status_code=200 is success
status_code=-1 is failure

=============================================================================
Configuring apache2
Install apache2 edit the default index.html file,restart apache2
and check if the apache2 is reachable or not

1 Install apache2
  ansible all -m apt -a 'name=apache2 state=present update_cache=yes' -b

2 Edit index.html file
  ansible all -m copy -a 'content="Welcome to IntelliQIT"                                           dest=/var/www/html/index.html' -b

3 Restart apache2
  ansible all -m service -a 'name=apache2 state=restarted' -b
 
4 Check url response of apache2 from all managed nodes
  ansible all -m uri -a 'url=http://172.31.37.220 status_code=200'
  ansible all -m uri -a 'url=http://172.31.36.172 status_code=200'

==================================================================================
get_url
=============
Ansible command to download jenkins.war on all managed nodes
 ansible all -m get_url -a 
          'url=http://mirrors.jenkins.io/war-stable/latest/jenkins.war dest=/tmp'


===========================================================================
Day 5
===========================================================================
Configuring tomcat8
Install tomcat8,copy tomcat-users.xml file,change port of tomcat
from 8080 to 9090 and restart tomcat8,check if tomcat is
reachable from all managed nodes

1 Install tomcat8
  ansible all -m apt -a 'name=tomcat8 state=present' -b

2 Copy the tomcat-users.xml file
  ansible all -m copy -a 'src=tomcat-users.xml dest=/etc/tomcat8' -b

3 Change port of tomcat from 8080 to 9090
  ansible all -m replace -a 'regexp=8080 replace=9090 
                                      path=/etc/tomcat8/server.xml' -b

4 Restart tomcat8
   ansible all -m service -a 'name=tomcat8 state=restarted' -b             

5 Check the url response of tomcat on all manged nodes
  ansible all -m uri -a 'url=http://172.31.37.220:9090 status_code=200'   
  ansible all -m uri -a 'url=http://172.31.36.172:9090 status_code=200'


===============================================================================
Playbooks
=============
Adhoc command are capable of working on only one module and 
only one set of arguments.For performing complex configuration
management activites adhoc command are difficult to handle
Instead we can use ansible playbooks
Playbooks are created using yml and a playbook is a combination of
plays.Each play is designed to perfrom specific activity on the 
managed nodes.These playbooks are designed to work on a single
managed nodes,group of nodes or all the nodes
The main advantage of playbooks over adhoc commands is reusability

Ansible playbook to create a user on managed nodes
vim playbook1.yml
---
- name: Create users on managed node
  hosts: all
  tasks:
   - name: Create a user
     user:
      name: Anu
      password: intelliqit
      uid: 1357
      home: /home/Anu
      shell: /bin/bash
...

To check if the playbook is created syntaxtically correct or not
ansible-playbook playbook1.yml --syntax-check

To execute the playbook
ansible-playbook playbook1.yml -b

==================================================================
Ansible playbook for configuring apache2
vim playbook2.yml
---
- name: Configuring apache2
  hosts: all
  tasks:
   - name: Install apache2
     apt:
      name: apache2
      state: present
      update_cache: yes
   - name: Edit the index.html file
     copy:
      content: "IntelliQIT"
      dest: /var/www/html/index.html
   - name: Restart apache2
     service:
      name: apache2
      state: restarted
   - name: Check url response of server1
     uri:
      url: http://172.31.37.220
      status_code: 200
   - name: Check url response of server2
     uri:
      url: http://172.31.36.172
      status_code: 200
...
============================================================
Ansible playbook for configuring tomcat
vim playbook3.yml
---
- name: Configuring tomcat
  hosts: all
  tasks:
   - name: Install tomcat8
     apt:
      name: tomcat8
      state: present
   - name: Copy tomcat-users.xml file
     copy:
      src: /home/ubuntu/tomcat-users.xml
      dest: /etc/tomcat8
   - name: Change tomcat port from 9090 to 8080
     replace:
      regexp: 9090
      replace: 8080
      path: /etc/tomcat8/server.xml
   - name: Restart tomcat8
     service:
      name: tomcat8
      state: restarted
   - name: Pause for some time
     pause:
      minutes: 2
   - name: Check url response of tomcat on server1
     uri:
      url: http://172.31.37.220:8080
      status_code: 200
   - name: Check url response of tomcat on server2
     uri:
      url: http://172.31.36.172:8080

======================================================================
Day 6
======================================================================


Variables in Ansible
============================
Variables are classified into 3 types
1 Global scope variables
2 Host Scope variables
3 Play Scope variables

Global Scope Variables are defined from the command prompt using
"extra_vars" and they have the highest level of priority

vim playbook4.yml
---
- name: Installing s/w using gloabl scope vaiables
  hosts: all
  tasks:
   - name: Install/uninstall s/w
     apt:
      name: "{{a}}"
      state: "{{b}}"
      update_cache: "{{c}}"
...

To run the playbook and uninstall git
ansible-playbook playbook4.yml --extra-vars "a=git b=absent c=no" -b

We can use the same playbook to do some other activity Eg: install java
ansible-playbook playbook4.yml --extra-vars "a=openjdk-8-jdk b=present c=yes" -b

==============================================================================
vim playbook5.yml
---
- name: Create users and create files or dirs in users home dir using global variabl
  hosts: all
  tasks:
   - name: Create user
     user:
      name: "{{a}}"
      password: "{{b}}"
      home: "{{c}}"
   - name: Create files/dirs in users home dir
     file:
      name: "{{d}}"
      state: "{{e}}"
...

WE can use the above playbook tp create multiple users and files/dir in their homedir
ansible-playbook playbook5.yml --extra-vars "a=Ramu b=intelliqit c=/home/Ramu                                               d=/home/Ramu/dir1 e=directory" -b

ansible-playbook playbook5.yml --extra-vars "a=Harish b=intelliqit c=/home/Harish                                                  d=/home/Harish/file1 e=touch" -b

=============================================================================
Playscope Variables
These variables have the least priority and they are defined in the playbook
in the "vars" section.
vim playbook6.yml
---
- name: Install/uninstal
  hosts: all
  vars:
   - a: tomcat8
   - b: present
   - c: no
  tasks:
   - name: Install uninstall s/w packages
     apt:
      name: "{{a}}"
      state: "{{b}}"
      update_cache: "{{c}}"
...

The above playbook works like a template whose default behaviour is to 
install tomcat8 but we can bypass that behaviour and make it work on some
other sets of data by passing them as global scope variables

ansible-playbook playbook6.yml --extra-vars "a=firewalld b= absent c=no" -b

==============================================================================
Grouping in inventory file
sudo vim /etc/ansible/hosts
[webserver]
172.31.37.220
172.31.36.172
[apserver]
172.31.39.147
[dbserver]
172.31.45.75
172.31.36.172
[servers:children]
webserver
apserver

===============================================================================

Host Scope Variables
-----------------------
These variables are further classified into 2 types
1) Variables to work on a group of hosts
2) Variables to work on a single host

Variables to work on a group of hosts
=========================================
These variables are create in a directory "group_vars"
This directory is created in the same folder where the playbooks
are present.In the group_vars directory we create a file whose
name is same as group name from the inventory file

1 Go to the folder where the playbooks are present
  cd path_of_playbooks_folder

2 Create a directory group_vars and move into it
  mkdir group_vars
  cd group_vars

3 Create a file whose name is same as a group name from the inventory file
  vim webserver
  ---
  a: Usha
  b: intelliqit
  c: 1111
  d: /home/Usha
  ...

4 Go back to the folder where the playbooks are present
  cd ..
  
5 Create a playbook for using the above variables
vim playbook9.yml
---
- name: User creation using host scope variables
  hosts: webserver
  tasks:
   - name: Create user
     user:
      name: "{{a}}"
      password: "{{b}}"
      uid: "{{c}}"
      home: "{{d}}"

6 To execute the playbook
  ansible-playbook playbook9.yml -b

==========================================================================
Day 7
==========================================================================
Variables to work on a single host
--------------------------------------
These variables should be created in a file whose name is same as ip
address of a remote managed node and this file should be created in
a folder called "host_vars" and this folder should be created in the folder
where all our playbooks are present

1 Go to the folder where the playbooks are present
  cd path_of_playbooks_folder

2 Create a directory host_vars and move into it
  mkdir host_vars
  cd host_vars

3 Create a file whose name is same as a ipaddress of a managed node
  from the inventory file
  vim 172.31.56.218
  ---
  a: firewalld
  b: present
  c: no
  ...

4 Go back to the folder where the playbooks are present
  cd ..

5 Create a playbook to use the above varibles
vim playbook10.yml
---
- name: Install firewall using host scope varibles
  hosts: 172.31.56.218
  tasks:
   - name: Install firewall
     apt:
      name: "{{a}}"
      state: "{{b}}"
      update_cache: "{{c}}"
...

6 To run the playbook
  ansible-playbook playbook10.yml -b

=========================================================================
Day 8
========================================================================
Loops in Ansible
=========================
Loops can be implemented in Ansible using "with_items"
and "with_sequence"

Ansible playbook to install multiple s/w packages using loops
vim playbook10.yml
---
- name: Implementing loops
  hosts: all
  tasks:
   - name: Install s/w packages
     apt:
      name: "{{item}}"
      state: present
      update_cache: no
     with_items:
      - tree
      - git
      - maven
      - firewalld
...

====================================================================

Ansible playbook to install,uninstall upgrade multiple s/w
packages

---
- name: Implementing loops
  hosts: all
  tasks:
   - name: Install s/w packages
     apt:
      name: "{{item.a}}"
      state: "{{item.b}}"
      update_cache: "{{item.c}}"
     with_items:
      - {a: tree,b: present,c: no}
      - {a: git,b: absent,c: no}
      - {a: maven,b: latest,c: yes}
      - {a: firewalld,b: absent,c: no}
...

===============================================================
---
- name: Create multiple users and copy files into their home directories
  hosts: all
  tasks:
   - name: Create multiple users
     user:
      name: "{{item.a}}"
      password: "{{item.b}}"
      uid: "{{item.c}}"
      home: "{{item.d}}"
     with_items:
      - {a: Ravi,b: intelliqit,c: 9090,d: /home/ubuntu/Ravi}
      - {a: Mallika,b: intelliqit,c: 8080,d: /home/Mallika}
   - name: Copy passwd file and group file
     copy:
      src: "{{item.a}}"
      dest: "{{item.b}}"
     with_items:
      - {a: /etc/passwd,b: /home/ubuntu/Ravi}
      - {a: /etc/group,b: /home/Mallika}

===============================================================
When Conditions
======================
This is similar to "if conditions" ie based on a condition
a module will be executed

---
- name: Implementing when conditions
  hosts: all
  vars:
   - a: 20
  tasks:
   - name: Create file based on a condition
     file:
      name: /tmp/file56
      state: touch
     when: a == 20
...

===========================================================================
---
- name: Check if d1 directory is present if not create file d1
  hosts: all
  tasks:
   - name: Check if d1 directory is present
     stat:
      path: /tmp/d1
     register: cat
   - name: Display output of the above module
     debug:
      var: cat
   - name: Create file d1 if directory d1 is not present
     file:
      name: /tmp/d1
      state: touch
     when: cat.stat.exists == false 
...

====================================================================
Day 9
====================================================================
Ansible playbook to setup the jenkins on one serverand tomcat on 
2 servers so that the jenkins admin can perfrom ci-cd

---
- name: Setup s/w required for jenkinsserver
  hosts: jenkins
  tasks:
   - name: Install necessary s/w
     apt:
      name: "{{item.a}}"
      state: "{{item.b}}"
      update_cache: "{{item.c}}"
     with_items:
      - {a: openjdk-8-jdk,b: present,c: yes}
      - {a: git,b: present,c: no}
      - {a: maven,b: present,c: no}
   - name: Download jenkins.war
     get_url:
      url: http://mirrors.jenkins.io/war-stable/latest/jenkins.war
      dest: /home/ubuntu
- name: Setup tomcat on qa and prodserver
  hosts: servers
  tasks:
   - name: Install tomcat8 and tomcat8-admin
     apt:
      name: "{{item.a}}"
      state: "{{item.b}}"
      update_cache: "{{item.c}}"
     with_items:
      - {a: tomcat8,b: present,c: yes}
      - {a: tomcat8-admin,b: present,c: no}
   - name: Copy tomcat-users.xml file
     copy:
      src: tomcat-users.xml
      dest: /etc/tomcat8
...

=================================================================
Handlers
1 Handlers are modules that are executed if some other module is executed
succesfully and it has made some changes.

2 Handlers are only executed after all the modules in the tasks section are executed

3 Handlers are executed in the order that they are mentioned in the handlers section and not in the order that they are called in the tasks section

4 Even if a handler is called multiple times in the tasks section it will
be executed only once

---
- name: Implementing handlers
  hosts: all
  tasks:
   - name: Install apache2
     apt:
      name: apache2
      state: present
     notify: Check url response
   - name: Edit index.html file
     copy:
      content: "Welcome to my IntelliQIT\n"
      dest: /var/www/html/index.html
     notify: Restart apache2
  handlers:
   - name: Restart apache2
     service:
      name: apache2
      state: restarted
   - name: Check url response
     uri:
      url: "{{item}}"
      status_code: 200
     with_items:
      - http://172.31.48.56
      - http://172.31.36.172
      - http://172.31.37.220

======================================================================
Day 10
========================================================================
Error Handling(Exception Handling)
========================================
If a module fails ansible stops the execution of the playbook
If we know that a certain module might fail and still we want
the execution of the playbook to continue we can use Error handling
The section of code that might generate an error shoudl be given
in the "block" section if it fails the control will come to the 
"rescue" section,"always" section is executed everytime irrespective
of whether the block section passes or fails

---
- name: Error Handling
  hosts: all
  tasks:
   - block:
      - name: Install tomcat7
        apt:
         name: tomcat7
         state: present
     rescue:
      - name: Install tomcat8
        apt:
         name: tomcat8
         state: present
     always:
      - name: Check url respose
        uri:
         url: "{{item}}"
         status_code: 200
        with_items:
         - http://172.31.37.220:8080
         - http://172.31.36.172:8080
         - http://172.31.48.56:8080

===================================================================
Ansible playbook to install apache2 on ubuntu nodes using apt module
and httpd on redhatlinux nodes using yum module

---
- name: Error Handling
  hosts: all
  tasks:
   - block:
      - name: Install via apt module
        apt:
         name: apache2
         state: present
     rescue:
      - name: Install via yum module
        yum:
         name: httpd
         state: present
...

=======================================================================

Ansible playbook to trigger the Continuous Integration/Continuous Delivery

---
- name: Perfroming CI-CD 
  hosts: devserver
  tasks:
   - name: Install required s/w
     apt:
      name: "{{item.a}}"
      state: present
      update_cache: "{{item.b}}"
     with_items:
      - {a: openjdk-8-jdk,b: yes}
      - {a: git,b: no}
      - {a: maven,b: no}
   - name: Download code from git
     git:
      repo: https://github.com/intelliqittrainings/maven.git
      dest: /home/ubuntu/dev
   - name: Build the code
     shell: cd /home/ubuntu/dev;mvn package
   - name: Fetch the artifact from devserver
     fetch:
      src: /home/ubuntu/dev/webapp/target/webapp.war
      dest: /tmp
- name: Install tomcat8 on qa and prodserver
  hosts: servers
  tasks:
   - name: Install tomcat8 and tomcat8-admin
     apt:
      name: "{{item}}"
      state: present
     with_items:
      - tomcat8
      - tomcat8-admin
      - git
      - openjdk-8-jdk
- name: Copy artifact into tomcat on QaServer and run the selenium test scripts
  hosts: qaserver
  tasks:
   - name: Copy the artifact
     copy: 
      src: /tmp/172.31.48.56/home/ubuntu/dev/webapp/target/webapp.war
      dest: /var/lib/tomcat8/webapps/qaenv.war
   - name: Download the selenium scripts
     git:
      repo: https://github.com/intelliqittrainings/FunctionalTesting.git
      dest: /home/ubuntu/qa
   - name: Execute the selenium scripts
     shell: java -jar /home/ubuntu/qa/testing.jar 
- name: Deploy artifact into prodservers
  hosts: prodserver
  tasks:
   - name: Copy artifact into prodserver tomcat
     copy:
      src: /tmp/172.31.48.56/home/ubuntu/dev/webapp/target/webapp.war
      dest: /var/lib/tomcat8/webapps/prodenv.war


==========================================================================
Day 11
==========================================================================
Tags 
====
Tags are alias for modules created in playbook
Using tags we can get much modular control over the execution of the playbooks

---
- name: Tagging in Ansible
  hosts: all
  tasks:
   - name: Install tree
     apt:
      name: tree
      state: present
     tags: tree_installation
   - name: User Creation
     user:
      name: Smaran
      password: intelliqit
     tags: user_creation
   - name: Copy passwd file
     copy:
      src: /etc/passwd
      dest: /tmp
...

To execute only the tagged modules
ansible-playbook playbook19.yml --tags=tagged -b

To execute only the untagged modules
ansible-playbook playbook19.yml --tags=untagged -b

To execute modules with a specific tag name
ansible-playbook playbook19.yml --tags=user_creation -b

====================================================================
Ansible Vault
=================
This is a feature of ansible where we set password to encrypt the data
in a playbook

1 To create a vault playbook
  ansible-vault create playbook_name.yml

2 To view the content of a vault playbook
  ansible-vault view playbook_name.yml

3 To edit the content of a vault playbook
  ansible-vault edit playbook_name.yml

4 To reset the password of a vault playbook
  ansible-vault rekey playbook_name.yml

5 To convert an ordinary playbook into a vault playbook
  ansible-vault encrypt playbook_name.yml

6 To convert a vault playbook into a normal playbook
  ansible-vault decrypt playbook_name.yml

=============================================================================
Calling child playbook
============================
include module is used for calling child playbooks from a parent playbook

Child playbook
====================
vim playbook21.yml
---
- name: Uninstall firewalld
  apt:
   name: firewalld
   state: absent
   update_cache: yes
...

Parent playbook
========================
vim playbook22.yml
---
- name: Call child playbook to uninstall firewalld
  hosts: all
  tasks:
   - name: call child playbook
     include: playbook21.yml
...

To execute
ansible-playbook playbook22.yml -b

=================================================================================
Configuring tomcat8 using child playbooks
===============================================
Child playbooks
------------------
vim install.yml
---
- name: Install tomcat8
  apt:
   name: tomcat8
   state: present
   update_cache: no
...

vim copy_tomcat_users.yml
---
- name: Copy tomcat-users.xml file
  copy:
   src: tomcat-users.xml
   dest: /etc/tomcat
...

vim replace.yml
---
- name: Change port of tomcat from 8080 to 9090
  replace:
   regexp: 8080
   replace: 9090
   path: /etc/tomcat8/server.xml
...

vim restart.yml
---
- name: Restart tomcat8
  service:
   name: tomcat8
   state: restarted
...

vim check_url_response.yml
---
- name: Check url response
  uri:
   url: "{{item}}"
   status_code: 200
  with_items:
   - http://172.31.37.220:9090
   - http://172.31.36.172:9090
   - http://172.31.48.56:9090
...

PArent playbook
vim configure_tomcat.yml
---
- name: Configuring tomcat using child playbooks
  hosts: all
  tasks:
   - name: Call multiple child playbooks
     include: "{{item}}"
     with_items:
      - install.yml
      - copy_tomcat_users.yml
      - replace.yml
      - restart.yml
      - check_url_response.yml
...
To execute
ansible-playbook configure_tomcat.yml -b

===========================================================================
Day 12
==========================================================================
Configuring apache2 using child playbooks and host scope variables

Child playbooks
================================
vim install_apache.yml
---
- name: Install apache2
  apt:
   name: "{{a}}"
   state: "{{b}}"
   update_cache: "{{c}}"
...

vim edit_index.yml
---
- name: Edit index.html file
  copy:
   src: "{{d}}"
   dest: "{{e}}"
...

vim restart_apache2.yml
---
- name: Restart apache2
  service:
   name: "{{a}}"
   state: "{{f}}"
...

File used in edit_index.yml file

vim index.html
<html>
        <body>
            <h1>Welcome to IntelliQIT</h1>
         </body>
</html>

To create group variables
Create group_vars in the directory where the above playbooks are present
mkdir group_vars
cd group_vars

Create a file whose name is same as group name from inventroy file
vim servers
---
a: apache2
b: present
c: yes
d: /home/ubuntu/ansible/index.html
e: /var/www/html
f: restarted
...

Go back to the folder where the playbooks are present 
cd ..

Create the parent playbook
vim configure_apache.yml
---
- name: Call child playbooks for apache2 configuration
  hosts: servers
  tasks:
   - name: Call multiple child playbooks
     include: "{{item}}"
     with_items:
      - install_apache.yml
      - edit_index.yml
      - restart_apache2.yml

To execute the playbook
ansible-playbook configure_apache.yml

==============================================================
Jenkins Ansible Integrations
===================================
a) If Jenkins and Asnible controler are on same server
   
   Free Style Project
   --------------------
   1)  Open the dashboard of Jenkins
   2) Click on Manage Jenkins--->Click on Manage Plugins
   3) Go to Availabels section---->Search for Ansible plugin
   4) Click on Instal without restart
   5) Go to Manage jenkins--->Click on Global tool configuration
   6) Go to Ansible section
      Give some name for thr ansible installtion
      and pasth of ansible  : /usr/bin   (which ansible)
   7) Click on Save
   8) Create a Free style project
   9) Go to Build section--->Click on Add Build step
   10) Select Ansible playbookexecution
       Enter the path of the ansible playbook
   11) Apply---->Save

   Pipeline Project
   -------------------
   1) Create a pipeline project
   2) Go to Pipeline syntax genarator
   3) select ansible
      Specify the path of ansible playbook and the path of inventory file
   4) Click on Genrate pipeline code
   5) Copy the groovy code and use it in the jenkinsfile

b) If Jenkins is on a seperate server
   a) Establish password less shh between Jenkins and Controller
   b) Open the dashboard of Jenkins
   c) Create a Free style project
   d) Go to Build section---->Click on Add build step
   e) Click on Execute shell
      ssh ubuntu@private_ip_of_controller  ansible-playbook path_of_playbook
   
  Note: If it a pipeline job take the shh command from step e and convert into
        groovy code and use in Jenkinsfile

================================================================================
Day 13
=================================================================================
Ansible Roles
========================
This is used for creating playbooks in a much more reusable way
Generally it is used for configuring components related to a
specific s/w application and a role will contain every thing
that is necessary for configuring a s/w application

A role is a predefined folder structure and each sub folder
is created for a specific purpose.We need to understand the 
purpose of these folders and place those components in those
folders 

All the ansible roles are availabel in the cloud site of ansible
called as ansible galaxy.We can download the roles from here or
create new roles on our own

Roles should be created in /etc/ansible/roles folder

If we want to create roles in some other folder we should edit
the ansible.cfg file
sudo vim /etc/ansible/ansible.cfg
Search for "roles path" and uncomment it and specify the path of the
folder where we want to create a role

=================================================================
Folders present in roles
============================
1 README.MD This is a text file where we store detailed info about
the s/w application that we are configuring using this roles

2 defaults: This is used to store info about the application in yaml format
and it is also used for storing variables of lesser priority

3 file: All the configuring files that are necessary for configuring a 
   s/w application are stored here

4 handlers: Handlers are modules that are triggered when some other modules
is executed successfully and also it has maode some changes,all such handlers
are stored in this folder

5 meta: Data about the data is called as metadata,here we store info about 
the roles like whcih OS it supports,Who is the author,when it was created etc
 
6 tasks: The actual configuration that is done on the remote servers is 
stored in this folder

7 templates: This is used for storing dynamic configuration files

8 test: Modules that are used to test if the remote configuration are
  done or not are stored in this fodler

9 vars: Used for stored the varibales used by this role.These variables
  have higher priority than the variables in the defaults folder

=================================================================================
Day 14
=================================================================================

Apache Role
========================
1 Go into the /etc/ansible/roles folder
  cd /etc/ansible/roles

2 Create a new role for apache2
  ansible-galaxy init apache2 --offline

3 check the tree structure of the role that we created
  tree apache2

4 Go to tasks folder in role and create the task for configuring apache2
  cd apache2/tasks
vim main.yml
---
- include: install.yml
- include: configure.yml
- include: check_url_response.yml
...

Save and quit    Esc :wq Enter

vim install.yml
---
- name: install apache2
  apt:
   name: apache2
   state: latest

Save and quit Esc :wq Enter

vim configure.yml
---
- name:copy index.html
  copy:
   src: index.html
   dest: /var/www/html/index.html
  notify:
   Restart apache2 
...
 
Save and quit Esc :wq Enter

vim check_url_response.yml
---
- name: Check url response
  uri:
   url: "{{item}}"
   status: 200
  with_items:
   - http://172.31.18.210
   - http://172.31.31.227
...

Save and quit Esc :wq Enter

Go to files folder to create the index.html file
cd ..
cd files
sudo vim index.html
<html>
  <body>
     <h1>This is IntelliQ</h1>
  </body>
</html>

Save and quit Esc :wq Enter

Go to handlers folder
cd ..
cd handlers

sudo vim main.yml
---
# handlers file for apache2
- name: Restart apache2
  service:
   name: apache2
   state: restarted
...

Save and quit Esc :wq Enter

Create the parent playbook to call the roles
cd ..
cd ..
sudo vim apache_role.yml
---
- name: Implementing roles for apache2
  hosts: all
  roles:
   - apache2
...

Save and quit Esc :wq Enter

To execute the role
ansible-playbook apache_role.yml -b

==============================================================================

Creating roles for tomcat

---------------------------

1 cd /etc/ansible/roles

2 ansible-galaxy init tomcat --offline

3 Create tasks for tomcat

  a) cd tomcat/tasks

  b) sudo vim main.yml

  ---

  - name: Calling child playbooks

    include: "{{item}}"

    with_items: 

     - install.yml

     - configure.yml

     - restart.yml

  ...

  Save and quit

 c) sudo vim install.yml

---

- name: Installing tomcat8 and tomcat8-admin

  apt:

   name: "{{item.a}}"

   state: "{{item.b}}"

   update_cache: "{{item.c}}"

  with_items:

   - {a: "{{pkg1}}",b: "{{state1}}",c: "{{cache1}}"}

   - {a: "{{pkg2}}",b: "{{state1}}",c: "{{cache2}}"}

...



d) sudo vim configure.yml

---

- name: Copy tomcat-user.xml 

  copy:

   src: "{{file1}}"

   dest: "{{destination1}}"

- name: Change port of tomcat from 8080 to 9090

  replace:

   path: "{{path1}}"

   regexp: "{{port1}}"

   replace: "{{port2}}"

  notify:

   - check_url_response

...



e) sudo vim restart.yml

---

- name: Restart tomcat8

  service:

   name: "{{pkg1}}"

   state: "{{state3}}"

...

4) Create the handlers

   cd ..
   cd handlers

   sudo vim main.yml

---

# handlers file for tomcat

- name: check_url_response

  uri:

   url: "{{item.a}}"

   status: "{{item.b}}"

  with_items:

   - {a: "{{server1}}",b: "{{status1}}"}

   - {a: "{{server2}}",b: "{{status1}}"}

...


5) create static files

   cd ..
   cd files

  a)   sudo vim tomcat-users.xml
   <tomcat-users>
    <user username="intelliq" password="myintelliq" roles="manager-                                                                         script"/>
  </tomcat-users>

  Save and quit

 
6) Define the variables
   cd ..
   cd vars
   sudo vim main.yml
---
# vars file for tomcat
pkg1: tomcat8
pkg2: tomcat8-admin
state1: present
state2: absent
state3: restarted
cache1: yes
cache2: no
file1: tomcat-users.xml
destination1: /etc/tomcat8
server1: http://172.31.87.8:9090
server2: http://172.31.84.59:9090
status1: 200
status2: -1
path1: /etc/tomcat8/server.xml
port1: 8080
port2: 9090
...

7 Come out of the tomcat roles
  cd ../..

8 Create a playbook to call that role
  sudo vim configure_tomcat.yml
---
- name: Configuring tomcat using roles
  hosts: all
  roles:
   - tomcat
...

9 To run the playbook for the above role
  ansible-playbook configure_tomcat.yml -b

=================================================================
Day 15
=================================================================
Ansible playbook to install on docker and docker-py

---
- name: Setup of docker for Ansible
  hosts: all
  tasks:
   - name: Install pip
     apt:
      name: python-pip
      state: present
      update_cache: yes
   - name: Download and  install docker and also docker-py
     shell: "{{item}}"
     with_items:
      - curl -fsSL https://get.docker.com -o get-docker.sh
      - sh get-docker.sh
      - pip install docker-py
...

Ansible playbook to start stop and delete a container
---
- name: Working on docker containers
  hosts: all
  tasks:
   - name: Start a httpd container
     docker_container:
      image: httpd
      name: h1
   - name: Stop the httpd container
     docker_container:
      name: h1
      state: stopped
   - name: Delete the httpd container
     docker_container:
      name: h1
      state: absent
...


Ansible playbook to create 10 nginx containers
---
- name: Start 10 nginx contianers on all maanged nodes
  hosts: all
  tasks:
   - name: Create 10 nginx
     docker_container:
      image: nginx
      name: "container{{item}}"
     with_sequence: count=10
...

=======================================================

Ansible playbook to implement docker compose on managed nodes
---
- name: Implementing docker compose using Ansible
  hosts: all
  tasks:
   - name: Create a mysql container
     docker_container:
      name: mydb
      image: mysql:5
      env:
       MYSQL_ROOT_PASSWORD: intelliqit

   - name: Create a wordpress container
     docker_container:
      name: wordpress
      image: wordpress
      ports:
       - 5555:80
      links:
       - mydb:mysql
...

===========================================================================
Day 16
===========================================================================
---
- name: Creating jenkins-tomcat setup for  CI-CD using docker/ansible
  hosts: all
  tasks:
   - name: Create a jenkins contianer
     docker_container:
      image: jenkins
      name: myjenkins
      ports:
       - 5050:8080

   - name: Create a tomcat for QAServer and ProdServer
     docker_container:
      image: tomcat
      name: "{{item.a}}"
      ports:
       - "{{item.b}}"
      links:
       - myjenkins:jenkins
     with_items:
      - {a: qaserver,b: "6060:8080"}
      - {a: prodserver,b: "7070:8080"}

=======================================================================
---
- name: Create an ubuntu container and mount a volume
  hosts: all
  tasks:
   - name: Create a ubuntu container
     docker_container:
      name: myubuntu
      image: ubuntu
      volumes:
       - /data
      interactive: yes
      tty: yes
======================================================================
---
- name: Ansible playbook to Download docker images
  hosts: all
  tasks:
   - name: Docker docker images
     docker_image:
      name: "{{item}}"
     with_items:
      - httpd
      - nginx
      - centos
      - jenkins
...

============================================================================
---
- name: Login into hub.docker.com and push a customised docker image
  hosts: 172.31.36.172
  tasks:
   - name: Login into docker hub
     docker_login:
      username: sai
      password: sai123
      email: intelliqit@gmail.com
   - name: Push the image
     docker_image:
      name: intelliqit/ubuntu_july16
      push: yes

============================================================================
Day 17
===========================================================================
Ansible playbook to intitilze the docker swarm

- name: Initilise the docker swarm on manager
  hosts: manager
  tasks:
   - name: Create docker swarm
     docker_swarm:
      state: present

To generate the toke id for workers to joun swarm
ansible manager -m shell -a 'docker swarm join-token worker' -b

Playbook to add workers to the swarm
---
- name: Join workers to the swarm cluster
  hosts: workers
  tasks:
   - name: Join workers to swarm
     docker_swarm:
      state: join
      advertise_addr: 172.31.37.220
      join_token: SWMTKN-1-33hmtvum9qegdk4t1gnn869by61mpsr49w1jkszvt6z18xfw0r-22f59e3w9xu46wsdwkqlce2zo
      remote_addrs: [ '172.31.37.220:2377' ]


==============================================================================

Vagrant
===================
1 Download and install Oracle virtual Box
  https://www.virtualbox.org/wiki/Downloads

2 Download and install vagrant
  https://www.vagrantup.com/downloads.html

3 To check if vagrant is installed
  vagrant --version

4 Copy the vagrantfile into an empty folder

5 Open cmd prompt
  cd path_of_folder_where_vagrantfile_is_copied
  vagrant up

6 To destroy the VM's
  vagrant destroy

===================================================================
